package com.codedigest.ix.domain

import android.content.Context
import android.net.Uri
import androidx.documentfile.provider.DocumentFile
import com.codedigest.ix.data.DigestConfig
import com.codedigest.ix.data.ProcessingState
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn // مهم جداً
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.util.regex.Pattern

class DigestEngine(private val context: Context) {

    private val binaryExtensions = setOf(
        "mp4", "avi", "mov", "mkv", "jpg", "jpeg", "png", "gif", "bmp", "svg", "ico",
        "pdf", "zip", "tar", "gz", "rar", "exe", "dll", "so", "dylib", "bin", "dat",
        "apk", "jar", "class", "dex", "lock", "db", "sqlite", "eot", "ttf", "woff", "woff2"
    )

    private val commentsRegex = Regex(
        "(//.*)|(/\\*[\\s\\S]*?\\*/)|(#.*)|(\"\"\".*?\"\"\")", 
        RegexOption.MULTILINE
    )

    suspend fun process(config: DigestConfig): Flow<ProcessingState> = flow {
        // 1. إرسال حالة المسح فوراً لتحديث الواجهة
        emit(ProcessingState.Scanning)

        // تنفيذ كل شيء داخل بلوك واحد لضمان عدم التجميد
        try {
            val rootDir = DocumentFile.fromTreeUri(context, config.sourceUri!!) 
                ?: throw Exception("Cannot access source folder")

            // تحضير قائمة التجاهل
            val ignorePatterns = mutableListOf<String>()
            ignorePatterns.addAll(config.excludePatterns)
            
            if (config.useGitIgnore) {
                rootDir.findFile(".gitignore")?.let { file ->
                    ignorePatterns.addAll(readLinesFromUri(file.uri))
                }
            }
            
            config.customGitIgnoreUri?.let { uri ->
                ignorePatterns.addAll(readLinesFromUri(uri))
            }

            // فحص الملفات (العملية الثقيلة)
            val allFiles = mutableListOf<DocumentFile>()
            val treeBuilder = StringBuilder()
            
            if (!config.skipTree) {
                treeBuilder.appendLine("Directory Structure for: ${rootDir.name}")
                treeBuilder.appendLine(rootDir.name ?: "root")
            }

            // هذا الاستدعاء كان يسبب التجميد، الآن هو داخل FlowOn(IO)
            traverseDirectory(rootDir, "", "", config, ignorePatterns, allFiles, treeBuilder)

            val totalFiles = allFiles.size
            if (totalFiles == 0) {
                emit(ProcessingState.Error("No matching files found!"))
                return@flow
            }

            // تحضير ملف الإخراج
            val outDir = File("/storage/emulated/0/CodeDigest")
            if (!outDir.exists()) outDir.mkdirs()
            val outFile = File(outDir, "${rootDir.name}_Digest.txt")
            
            FileOutputStream(outFile).use { fos ->
                val writer = fos.bufferedWriter()
                writer.write("Project Digest: ${rootDir.name}\n")
                writer.write("Total Files: $totalFiles\n")
                if (config.showTokenCount) writer.write("Approx Tokens: CALCULATING...\n") 
                writer.write("Generated by CodeDigest App\n")
                writer.write("------------------------------------------------\n\n")
                if (!config.skipTree) {
                    writer.write(treeBuilder.toString())
                    writer.write("\n\n")
                }
                writer.flush()
            }

            // بدء المعالجة
            var processedCount = 0
            var totalTokens = 0L
            val writeMutex = Mutex()
            
            // زيادة حجم الدفعة لسرعة أكبر
            val chunkSize = 20 
            allFiles.chunked(chunkSize).forEach { batch ->
                val results = batch.map { file ->
                    processFileContent(file, config)
                }
                
                writeMutex.withLock {
                    FileOutputStream(outFile, true).bufferedWriter().use { writer ->
                        results.forEach { (content, tokens) ->
                            if (content.isNotEmpty()) {
                                writer.write(content)
                                totalTokens += tokens
                            }
                        }
                    }
                    processedCount += batch.size
                    // تحديث الواجهة
                    emit(ProcessingState.Processing(
                        currentFile = "Batch ${processedCount / chunkSize}", 
                        progress = processedCount.toFloat() / totalFiles,
                        totalFiles = totalFiles,
                        processed = processedCount
                    ))
                }
            }

            if (config.showTokenCount) {
                 FileOutputStream(outFile, true).bufferedWriter().use { writer ->
                     writer.write("\n\n------------------------------------------------\n")
                     writer.write("FINAL SUMMARY:\n")
                     writer.write("Total Files Processed: $processedCount\n")
                     writer.write("Approximate Token Count: ~$totalTokens\n")
                 }
            }

            emit(ProcessingState.Success(Uri.fromFile(outFile), 
                "Saved to: ${outFile.absolutePath}\nTokens: ~$totalTokens"))

        } catch (e: Exception) {
            emit(ProcessingState.Error(e.message ?: "Unknown Error"))
        }
    }.flowOn(Dispatchers.IO) // <--- هذا السطر هو الحل السحري لمشكلة التجميد

    private fun readLinesFromUri(uri: Uri): List<String> {
        return try {
            context.contentResolver.openInputStream(uri)?.bufferedReader()?.readLines()
                ?.map { it.trim() }
                ?.filter { it.isNotEmpty() && !it.startsWith("#") } 
                ?: emptyList()
        } catch (e: Exception) { emptyList() }
    }

    private suspend fun traverseDirectory(
        dir: DocumentFile,
        prefix: String,
        relativePath: String,
        config: DigestConfig,
        ignorePatterns: List<String>,
        fileCollector: MutableList<DocumentFile>,
        treeBuilder: StringBuilder
    ) {
        val files = dir.listFiles().sortedBy { it.name?.lowercase() }
        
        val validItems = files.filter { file ->
            val path = if (relativePath.isEmpty()) file.name ?: "" else "$relativePath/${file.name}"
            !shouldIgnore(path, ignorePatterns) && file.name != ".git"
        }

        val count = validItems.size
        validItems.forEachIndexed { index, file ->
            val isLast = index == count - 1
            val name = file.name ?: "unknown"
            val currentPath = if (relativePath.isEmpty()) name else "$relativePath/$name"

            if (!config.skipTree) {
                treeBuilder.append(prefix)
                treeBuilder.append(if (isLast) "└── " else "├── ")
                treeBuilder.appendLine(name)
            }

            if (file.isDirectory) {
                val newPrefix = prefix + if (isLast) "    " else "│   "
                traverseDirectory(file, newPrefix, currentPath, config, ignorePatterns, fileCollector, treeBuilder)
            } else {
                if (!isBinaryFile(file, config)) {
                    fileCollector.add(file)
                }
            }
        }
    }

    private suspend fun processFileContent(file: DocumentFile, config: DigestConfig): Pair<String, Int> {
        return try {
            val sb = StringBuilder()
            context.contentResolver.openInputStream(file.uri)?.use { stream ->
                var text = stream.bufferedReader().readText()
                
                if (config.removeComments) {
                    text = commentsRegex.replace(text, "")
                }

                sb.appendLine("================================================")
                sb.appendLine("FILE: ${file.name}")
                sb.appendLine("================================================")

                if (config.compactMode) {
                    text.lineSequence()
                        .filter { it.isNotBlank() }
                        .forEach { sb.appendLine(it) }
                } else {
                    sb.appendLine(text)
                }
                sb.appendLine()
                
                val tokens = (text.length / 4)
                Pair(sb.toString(), tokens)
            } ?: Pair("", 0)
        } catch (e: Exception) { Pair("", 0) }
    }

    private fun isBinaryFile(file: DocumentFile, config: DigestConfig): Boolean {
        val name = file.name ?: return false
        val ext = name.substringAfterLast('.', "").lowercase()
        if (binaryExtensions.contains(ext)) return true
        if (config.fastMode) return false
        
        return try {
            context.contentResolver.openInputStream(file.uri)?.use { stream ->
                val buffer = ByteArray(512)
                val read = stream.read(buffer)
                (0 until read).any { buffer[it].toInt() == 0 }
            } ?: false
        } catch (e: Exception) { false }
    }

    private fun shouldIgnore(path: String, patterns: List<String>): Boolean {
        return patterns.any { pattern ->
            val p = pattern.replace(".", "\\.").replace("*", ".*")
            Pattern.compile(p).matcher(path).find()
        }
    }
}
